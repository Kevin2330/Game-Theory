<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chomp (K×K)</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #f7f7f8;
        --panel-bg: #ffffffcc;
        --border: #c2c8d0;
        --accent: #2f6fed;
        --accent-muted: #aac3ff;
        --poison: #d64545;
        --poison-bg: rgba(214, 69, 69, 0.12);
        --p1: #227c9d;
        --p2: #ffb703;
        --helper: #0f766e;
        --solver: #7c3aed;
        font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
          "Helvetica Neue", sans-serif;
        background-color: var(--bg);
      }

      body {
        margin: 0;
        background: linear-gradient(180deg, #fdfdfd 0%, #eef3ff 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        color: #1f2933;
      }

      header {
        padding: 1.5rem clamp(1rem, 3vw, 3rem);
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 1px 8px rgba(15, 23, 42, 0.08);
        backdrop-filter: blur(8px);
        position: sticky;
        top: 0;
        z-index: 5;
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: clamp(1.6rem, 3vw, 2.2rem);
      }

      header p {
        margin: 0;
        max-width: 60ch;
        line-height: 1.5;
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(280px, 360px) minmax(0, 1fr) minmax(
            220px,
            320px
          );
        gap: clamp(1rem, 3vw, 2rem);
        padding: clamp(1rem, 3vw, 2.5rem);
        align-items: start;
      }

      @media (max-width: 1100px) {
        main {
          grid-template-columns: minmax(280px, 360px) minmax(0, 1fr);
          grid-template-areas:
            "controls board"
            "notes notes";
        }

        .notes-panel {
          grid-area: notes;
        }
      }

      @media (max-width: 860px) {
        main {
          grid-template-columns: 1fr;
          grid-template-areas:
            "controls"
            "board"
            "notes";
        }

        .controls-panel,
        .board-panel,
        .notes-panel {
          width: min(100%, 520px);
          margin-inline: auto;
        }
      }

      .panel {
        background: var(--panel-bg);
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 1rem;
        padding: clamp(1rem, 2vw, 1.5rem);
        box-shadow: 0 1rem 2rem -1.5rem rgba(15, 23, 42, 0.4);
        backdrop-filter: blur(6px);
      }

      .controls-panel h2,
      .board-panel h2,
      .notes-panel h2 {
        margin-top: 0;
        margin-bottom: 0.75rem;
        font-size: 1.25rem;
        color: #0f172a;
      }

      .controls-panel {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .control-group {
        display: grid;
        gap: 0.5rem;
      }

      .control-group label {
        font-weight: 600;
      }

      .size-row {
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .size-row input[type="number"] {
        width: 5rem;
        padding: 0.45rem 0.65rem;
        border: 1px solid var(--border);
        border-radius: 0.6rem;
        font-size: 1rem;
        background: #fff;
      }

      button {
        cursor: pointer;
        border-radius: 0.7rem;
        border: 1px solid transparent;
        font-size: 0.95rem;
        font-weight: 600;
        padding: 0.55rem 0.95rem;
        background: #edf2ff;
        color: #1e3a8a;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      button:focus-visible {
        outline: 3px solid rgba(47, 111, 237, 0.45);
        outline-offset: 2px;
      }

      button:hover:not([aria-disabled="true"]) {
        transform: translateY(-1px);
        box-shadow: 0 6px 12px -8px rgba(15, 23, 42, 0.4);
      }

      button[aria-pressed="true"],
      button.toggle-on {
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        color: white;
        box-shadow: 0 6px 14px -8px rgba(37, 99, 235, 0.8);
      }

      button[disabled],
      button[aria-disabled="true"] {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
      }

      .toggle-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .action-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .board-panel {
        display: grid;
        gap: 1rem;
      }

      .board-wrapper {
        position: relative;
        overflow: hidden;
      }

      .board-container {
        display: grid;
        gap: 0.2rem;
        background: rgba(15, 23, 42, 0.05);
        padding: 0.4rem;
        border-radius: 0.9rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
      }

      .board-container .corner-cell,
      .board-container .index-cell {
        display: grid;
        place-items: center;
        font-size: 0.85rem;
        color: #475569;
        font-weight: 600;
      }

      .cell {
        position: relative;
        border-radius: 0.5rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: #fff;
        color: #111827;
        display: grid;
        place-items: center;
        min-height: 2.8rem;
        transition: background-color 0.15s ease, transform 0.12s ease,
          opacity 0.2s ease;
      }

      .cell[data-locked="true"] {
        cursor: not-allowed;
      }

      .cell.alive:hover,
      .cell.alive:focus-visible {
        background: rgba(37, 99, 235, 0.08);
      }

      .cell.removed {
        background: rgba(15, 23, 42, 0.04);
        border-style: dashed;
        color: transparent;
        pointer-events: none;
        opacity: 0.4;
      }

      .cell.preview {
        background: rgba(37, 99, 235, 0.14);
        box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.2);
      }

      .cell.poison {
        border: 2px solid var(--poison);
        background: var(--poison-bg);
        color: #b42318;
        font-weight: 700;
      }

      .cell.last-move {
        box-shadow: inset 0 0 0 2px rgba(34, 124, 157, 0.85);
      }

      .cell.mirror-suggestion {
        box-shadow: inset 0 0 0 3px rgba(15, 118, 110, 0.8);
        border-style: dotted;
      }

      .cell.solver-suggestion {
        box-shadow: inset 0 0 0 3px rgba(124, 58, 237, 0.85);
      }

      .cell[data-helper-tip]::after {
        content: attr(data-helper-tip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translate(-50%, -0.4rem);
        background: rgba(15, 23, 42, 0.85);
        color: #f8fafc;
        padding: 0.2rem 0.5rem;
        border-radius: 0.4rem;
        font-size: 0.7rem;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.12s ease;
      }

      .cell[data-helper-tip]:hover::after,
      .cell[data-helper-tip]:focus-visible::after {
        opacity: 1;
      }

      .status-area {
        display: grid;
        gap: 0.35rem;
        font-size: 0.98rem;
        background: rgba(255, 255, 255, 0.75);
        border-radius: 0.8rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: 0.8rem 1rem;
      }

      .status-area strong {
        color: #0f172a;
      }

      .status-area .turn-label {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }

      .turn-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.1rem 0.55rem;
        border-radius: 999px;
        font-size: 0.78rem;
        font-weight: 700;
        color: white;
      }

      .turn-pill.p1 {
        background: var(--p1);
      }

      .turn-pill.p2 {
        background: var(--p2);
        color: #3a2f09;
      }

      .status-area .message {
        min-height: 1.4em;
        color: #0f766e;
        font-weight: 600;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(15, 23, 42, 0.65);
        color: #f8fafc;
        padding: 1rem;
        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .overlay.visible {
        opacity: 1;
        pointer-events: auto;
      }

      .overlay-content {
        background: rgba(15, 23, 42, 0.92);
        border-radius: 0.9rem;
        padding: 1.5rem;
        max-width: 320px;
        display: grid;
        gap: 1rem;
      }

      .overlay-content button {
        background: #facc15;
        color: #3a2f09;
      }

      .notes-panel details {
        background: rgba(255, 255, 255, 0.85);
        border-radius: 0.8rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        padding: 0.9rem 1rem;
      }

      .notes-panel summary {
        cursor: pointer;
        font-weight: 700;
        font-size: 1rem;
      }

      .notes-panel p {
        margin-top: 0.7rem;
        margin-bottom: 0.75rem;
        line-height: 1.6;
      }

      .notes-panel ul {
        margin: 0.4rem 0 0.9rem 1.2rem;
        padding: 0;
        line-height: 1.5;
      }

      .notes-panel li::marker {
        color: #2563eb;
      }

      .solver-note {
        font-size: 0.85rem;
        color: #475569;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Chomp (K×K)</h1>
      <p>
        Rule: clicking (x<sub>kl</sub>) removes all (x<sub>ij</sub>) with (i ≤ k, j ≤ l).
        The player who clicks (x<sub>KK</sub>) <strong>loses</strong>.
      </p>
    </header>
    <main>
      <section class="panel controls-panel" aria-labelledby="controls-title">
        <h2 id="controls-title">Controls</h2>
        <div class="control-group" aria-live="polite">
          <label for="size-input">Board size K (2–12)</label>
          <div class="size-row">
            <input
              id="size-input"
              type="number"
              min="2"
              max="12"
              value="6"
              aria-describedby="size-help"
            />
            <button id="apply-size" type="button">Reset</button>
          </div>
          <span id="size-help" class="solver-note">
            Changing K rebuilds the square board.
          </span>
        </div>

        <div class="control-group">
          <span class="sr-only" id="mode-label">Opponent mode</span>
          <div class="toggle-group" role="group" aria-labelledby="mode-label">
            <button
              id="mode-toggle"
              type="button"
              aria-pressed="false"
            >
              Mode: Human vs Human
            </button>
          </div>
        </div>

        <div class="control-group">
          <span class="sr-only" id="helpers-label">Helpers</span>
          <div class="toggle-group" role="group" aria-labelledby="helpers-label">
            <button
              id="helper-toggle"
              type="button"
              aria-pressed="true"
            >
              P1 Helper: On
            </button>
            <button
              id="solver-toggle"
              type="button"
              aria-pressed="false"
              aria-disabled="false"
            >
              Small-K Solver: Off
            </button>
          </div>
          <span class="solver-note" id="solver-note"
            >Exact solver available only when K ≤ 6.</span
          >
        </div>

        <div class="control-group">
          <div class="action-row">
            <button id="undo-btn" type="button">Undo</button>
            <button id="new-game-btn" type="button">New Game</button>
            <button id="random-btn" type="button">Randomize First Move</button>
          </div>
        </div>
      </section>

      <section class="panel board-panel" aria-labelledby="board-title">
        <h2 id="board-title">Board</h2>
        <div class="board-wrapper">
          <div
            id="board"
            class="board-container"
            role="grid"
            aria-label="Chomp board"
          ></div>
          <div id="overlay" class="overlay" role="alert" aria-live="assertive">
            <div class="overlay-content">
              <p id="overlay-message"></p>
              <button id="play-again" type="button">Play again</button>
            </div>
          </div>
        </div>
        <div class="status-area" aria-live="polite">
          <div class="turn-label">
            <span>Turn:</span>
            <span id="turn-pill" class="turn-pill p1">P1</span>
            <span id="turn-text">P1</span>
          </div>
          <div id="last-move">Last move: —</div>
          <div id="terminal-note" class="terminal"></div>
          <div class="message" id="status-message"></div>
        </div>
      </section>

      <aside class="panel notes-panel" aria-labelledby="notes-title">
        <h2 id="notes-title">Side Notes</h2>
        <details open>
          <summary>Why P1 wins on a square</summary>
          <p>
            Why P1 wins on a square: <strong>strategy-stealing</strong>. If P2 had a
            winning plan, P1 could make a harmless opening tweak and then copy
            that plan with at least as much freedom—contradiction.
          </p>
          <p>
            The mirror helper illustrates a common symmetry idea on squares. It
            is a <strong>rule of thumb</strong>, not a full strategy for every
            shape.
          </p>
          <p>
            Small-K solver is exact only for <strong>K ≤ 6</strong> to keep the
            demo responsive.
          </p>
          <ul>
            <li>
              Mirror rule: when the shape is symmetric about the main diagonal,
              P1 can reply to any off-diagonal move (x<sub>ij</sub>) with its
              mirror (x<sub>ji</sub>), keeping symmetry intact.
            </li>
            <li>
              Solver highlight: the recursive search shows one winning move when
              the position is a P-position for the player to move.
            </li>
          </ul>
        </details>
      </aside>
    </main>

    <script>
      const state = {
        K: 6,
        alive: [],
        moveLog: [],
        helperEnabled: true,
        solverEnabled: false,
        vsBot: false,
        gameOver: false,
        gameOverInfo: null,
        pendingBot: null,
      };

      const solverCache = new Map();
      const boardContainer = document.getElementById("board");
      const overlay = document.getElementById("overlay");
      const overlayMessage = document.getElementById("overlay-message");
      const playAgainBtn = document.getElementById("play-again");
      const sizeInput = document.getElementById("size-input");
      const applySizeBtn = document.getElementById("apply-size");
      const modeToggle = document.getElementById("mode-toggle");
      const helperToggle = document.getElementById("helper-toggle");
      const solverToggle = document.getElementById("solver-toggle");
      const solverNote = document.getElementById("solver-note");
      const undoBtn = document.getElementById("undo-btn");
      const newGameBtn = document.getElementById("new-game-btn");
      const randomBtn = document.getElementById("random-btn");
      const turnPill = document.getElementById("turn-pill");
      const turnText = document.getElementById("turn-text");
      const lastMoveEl = document.getElementById("last-move");
      const terminalNote = document.getElementById("terminal-note");
      const statusMessage = document.getElementById("status-message");
      let cellElements = [];
      let previewCells = [];

      function init(newK) {
        cancelBot();
        state.K = newK;
        initializeBoardState();
        buildBoardGrid();
        render();
        updateControls();
      }

      function initializeBoardState() {
        state.alive = Array.from({ length: state.K }, () =>
          Array(state.K).fill(true)
        );
        state.moveLog = [];
        state.gameOver = false;
        state.gameOverInfo = null;
        clearPreview();
      }

      function buildBoardGrid() {
        boardContainer.innerHTML = "";
        boardContainer.style.gridTemplateColumns = `3rem repeat(${state.K}, minmax(2.5rem, 1fr))`;
        boardContainer.style.gridTemplateRows = `3rem repeat(${state.K}, minmax(2.5rem, 1fr))`;
        cellElements = Array.from({ length: state.K }, () =>
          Array(state.K)
        );

        const corner = document.createElement("div");
        corner.className = "corner-cell";
        boardContainer.appendChild(corner);

        for (let col = 1; col <= state.K; col += 1) {
          const colHeader = document.createElement("div");
          colHeader.className = "index-cell";
          colHeader.textContent = col;
          boardContainer.appendChild(colHeader);
        }

        for (let row = 1; row <= state.K; row += 1) {
          const rowHeader = document.createElement("div");
          rowHeader.className = "index-cell";
          rowHeader.textContent = row;
          boardContainer.appendChild(rowHeader);

          for (let col = 1; col <= state.K; col += 1) {
            const cell = document.createElement("button");
            cell.className = "cell alive";
            cell.dataset.row = String(row);
            cell.dataset.col = String(col);
            cell.dataset.baseTitle = `Clicking (x${subscript(row)}${subscript(
              col
            )}) removes all (x${subscript("i")}${subscript("j")}) with i ≤ ${row}, j ≤ ${col}`;
            cell.title = cell.dataset.baseTitle;
            cell.setAttribute("role", "gridcell");
            cell.setAttribute("aria-label", `Cell x${subscript(row)}${subscript(
              col
            )}`);
            cell.tabIndex = 0;
            if (row === state.K && col === state.K) {
              cell.classList.add("poison");
              cell.textContent = "☠";
            }
            cell.addEventListener("click", () => {
              handleCellSelection(row, col);
            });
            cell.addEventListener("mouseenter", () => {
              if (!isAlive(row, col)) return;
              setPreview(row, col);
            });
            cell.addEventListener("mouseleave", () => {
              clearPreview();
            });
            cell.addEventListener("focus", () => {
              if (!isAlive(row, col)) return;
              setPreview(row, col);
            });
            cell.addEventListener("blur", () => {
              clearPreview();
            });
            cell.addEventListener("keydown", (event) => {
              handleCellKey(event, row, col);
            });
            boardContainer.appendChild(cell);
            cellElements[row - 1][col - 1] = cell;
          }
        }
      }

      function handleCellSelection(row, col) {
        if (state.gameOver) return;
        if (state.vsBot && currentPlayer() === 2) return;
        if (!isAlive(row, col)) return;
        performMove(row, col);
      }

      function handleCellKey(event, row, col) {
        const { key } = event;
        if (key === " " || key === "Enter") {
          event.preventDefault();
          handleCellSelection(row, col);
          return;
        }
        const directions = {
          ArrowUp: [-1, 0],
          ArrowDown: [1, 0],
          ArrowLeft: [0, -1],
          ArrowRight: [0, 1],
        };
        if (!(key in directions)) return;
        event.preventDefault();
        const [dRow, dCol] = directions[key];
        const next = findNextAliveCell(row, col, dRow, dCol);
        if (next) {
          const cell = cellElements[next[0] - 1][next[1] - 1];
          if (cell) cell.focus();
        }
      }

      function findNextAliveCell(row, col, dRow, dCol) {
        let r = row + dRow;
        let c = col + dCol;
        while (r >= 1 && r <= state.K && c >= 1 && c <= state.K) {
          if (isAlive(r, c)) return [r, c];
          r += dRow;
          c += dCol;
        }
        return null;
      }

      function performMove(row, col) {
        if (!isAlive(row, col)) return;
        const player = currentPlayer();
        clearPreview();
        applyMoveInternal(player, row, col);
        const clickedPoison = row === state.K && col === state.K;
        if (clickedPoison) {
          state.gameOver = true;
          state.gameOverInfo = {
            loser: player,
            reason: "poison",
          };
          render();
          return;
        }
        render();
        if (!state.gameOver && state.vsBot && currentPlayer() === 2) {
          queueBotMove();
        }
      }

      function applyMoveInternal(player, row, col) {
        for (let r = 1; r <= row; r += 1) {
          for (let c = 1; c <= col; c += 1) {
            state.alive[r - 1][c - 1] = false;
          }
        }
        state.moveLog.push({ player, i: row, j: col });
      }

      function queueBotMove() {
        cancelBot();
        state.pendingBot = setTimeout(() => {
          state.pendingBot = null;
          executeBotMove();
        }, 480);
      }

      function cancelBot() {
        if (state.pendingBot) {
          clearTimeout(state.pendingBot);
          state.pendingBot = null;
        }
      }

      function executeBotMove() {
        if (!state.vsBot || state.gameOver || currentPlayer() !== 2) return;
        const legal = legalTargets();
        if (!legal.length) return;
        let move = null;
        if (state.solverEnabled && state.K <= 6) {
          const snapshot = snapshotMatrix();
          move = findWinningMove(snapshot);
        }
        if (!move) {
          move = mirrorReplyForBot();
        }
        if (!move) {
          const safeMoves = legal.filter(
            ([i, j]) => !(i === state.K && j === state.K)
          );
          const pool = safeMoves.length ? safeMoves : legal;
          move = pool[Math.floor(Math.random() * pool.length)];
        }
        if (move) {
          const [row, col] = move;
          if (isAlive(row, col)) {
            performMove(row, col);
          }
        }
      }

      function mirrorReplyForBot() {
        const last = lastMove();
        if (!last || last.player !== 1) return null;
        const { i, j } = last;
        if (i !== j && isAlive(j, i)) {
          return [j, i];
        }
        if (i === j) {
          for (let r = 1; r <= state.K; r += 1) {
            if (r === i) continue;
            if (isAlive(r, r)) {
              return [r, r];
            }
          }
        }
        return null;
      }

      function render() {
        updateBoardCells();
        updateStatus();
        updateHighlights();
        updateControls();
      }

      function updateBoardCells() {
        for (let row = 1; row <= state.K; row += 1) {
          for (let col = 1; col <= state.K; col += 1) {
            const cell = cellElements[row - 1][col - 1];
            if (!cell) continue;
            const alive = state.alive[row - 1][col - 1];
            cell.classList.toggle("alive", alive);
            cell.classList.toggle("removed", !alive);
            cell.dataset.locked = String(
              state.gameOver || (state.vsBot && currentPlayer() === 2)
            );
            cell.setAttribute(
              "aria-disabled",
              state.gameOver || (state.vsBot && currentPlayer() === 2)
                ? "true"
                : "false"
            );
            cell.tabIndex = alive ? 0 : -1;
            if (!alive) {
              cell.classList.remove("preview");
            }
            if (row === state.K && col === state.K) {
              cell.classList.add("poison");
            }
          }
        }
      }

      function updateStatus() {
        const turn = state.gameOver ? null : currentPlayer();
        if (turn) {
          turnPill.textContent = `P${turn}`;
          turnPill.classList.toggle("p1", turn === 1);
          turnPill.classList.toggle("p2", turn === 2);
          turnText.textContent = state.vsBot && turn === 2 ? "P2 (bot)" : `P${turn}`;
        } else {
          turnText.textContent = "Game over";
        }

        const last = lastMove();
        if (last) {
          lastMoveEl.textContent = `Last move: P${last.player} → (x${subscript(
            last.i
          )}${subscript(last.j)})`;
        } else {
          lastMoveEl.textContent = "Last move: —";
        }

        if (!state.gameOver && isTerminal()) {
          const kSub = subscript(state.K);
          terminalNote.textContent = `Terminal (only (x${kSub}${kSub}) remains). Next player would lose.`;
        } else {
          terminalNote.textContent = "";
        }

        if (state.gameOver && state.gameOverInfo) {
          overlay.classList.add("visible");
          const kSub = subscript(state.K);
          overlayMessage.textContent = `P${state.gameOverInfo.loser} loses (clicked (x${kSub}${kSub})).`;
        } else {
          overlay.classList.remove("visible");
          overlayMessage.textContent = "";
        }
      }

      function updateHighlights() {
        const helperNotes = new Map();
        for (let row = 1; row <= state.K; row += 1) {
          for (let col = 1; col <= state.K; col += 1) {
            const cell = cellElements[row - 1][col - 1];
            if (!cell) continue;
            cell.classList.remove("last-move", "mirror-suggestion", "solver-suggestion");
            cell.removeAttribute("data-helper-tip");
            const baseTitle = cell.dataset.baseTitle;
            cell.title = baseTitle;
          }
        }

        const last = lastMove();
        if (last) {
          const cell = cellElements[last.i - 1][last.j - 1];
          if (cell) {
            cell.classList.add("last-move");
          }
        }

        const mirror = mirrorSuggestion();
        if (mirror) {
          const cell = cellElements[mirror[0] - 1][mirror[1] - 1];
          if (cell) {
            cell.classList.add("mirror-suggestion");
            helperNotes.set(cell, ["Mirror move"]);
          }
        }

        const solverMove = solverSuggestion();
        if (solverMove) {
          const cell = cellElements[solverMove[0] - 1][solverMove[1] - 1];
          if (cell) {
            cell.classList.add("solver-suggestion");
            const notes = helperNotes.get(cell) || [];
            notes.push("Solver move");
            helperNotes.set(cell, notes);
          }
        }

        helperNotes.forEach((notes, cell) => {
          const baseTitle = cell.dataset.baseTitle;
          const extra = notes.join(" • ");
          cell.title = `${baseTitle}\n${extra}`;
          cell.setAttribute("data-helper-tip", extra);
        });
      }

      function updateControls() {
        modeToggle.setAttribute("aria-pressed", state.vsBot ? "true" : "false");
        modeToggle.textContent = state.vsBot
          ? "Mode: P1 vs Bot (P2)"
          : "Mode: Human vs Human";

        helperToggle.setAttribute(
          "aria-pressed",
          state.helperEnabled ? "true" : "false"
        );
        helperToggle.textContent = state.helperEnabled
          ? "P1 Helper: On"
          : "P1 Helper: Off";

        if (state.K > 6) {
          state.solverEnabled = false;
          solverToggle.setAttribute("aria-disabled", "true");
          solverToggle.setAttribute("disabled", "disabled");
          solverToggle.setAttribute("aria-pressed", "false");
          solverToggle.textContent = "Small-K Solver: Off";
          solverNote.textContent = "Exact solver available only when K ≤ 6.";
        } else {
          solverToggle.removeAttribute("disabled");
          solverToggle.setAttribute("aria-disabled", "false");
          solverToggle.setAttribute(
            "aria-pressed",
            state.solverEnabled ? "true" : "false"
          );
          solverToggle.textContent = state.solverEnabled
            ? "Small-K Solver: On"
            : "Small-K Solver: Off";
          solverNote.textContent =
            "Exact solver highlights a winning move when available.";
        }
      }

      function undo() {
        if (!state.moveLog.length) return;
        cancelBot();
        const remainingMoves = state.moveLog.slice(0, -1);
        initializeBoardState();
        for (const move of remainingMoves) {
          applyMoveInternal(move.player, move.i, move.j);
        }
        render();
      }

      function newGame() {
        cancelBot();
        initializeBoardState();
        render();
      }

      function randomizeFirstMove() {
        if (state.moveLog.length > 0) {
          flashStatus("Random first move is only available on an empty board.");
          return;
        }
        const legal = legalTargets();
        if (!legal.length) return;
        const safeMoves = legal.filter(
          ([i, j]) => !(i === state.K && j === state.K)
        );
        const pool = safeMoves.length ? safeMoves : legal;
        const move = pool[Math.floor(Math.random() * pool.length)];
        performMove(move[0], move[1]);
      }

      function flashStatus(message, timeout = 3000) {
        statusMessage.textContent = message;
        if (message) {
          setTimeout(() => {
            if (statusMessage.textContent === message) {
              statusMessage.textContent = "";
            }
          }, timeout);
        }
      }

      function setPreview(row, col) {
        clearPreview();
        previewCells = cellsToRemove(row, col);
        for (const [r, c] of previewCells) {
          const cell = cellElements[r - 1][c - 1];
          if (cell) cell.classList.add("preview");
        }
      }

      function clearPreview() {
        for (const [r, c] of previewCells) {
          const cell = cellElements[r - 1][c - 1];
          if (cell) cell.classList.remove("preview");
        }
        previewCells = [];
      }

      function isAlive(row, col) {
        return Boolean(state.alive[row - 1]?.[col - 1]);
      }

      function isTerminal() {
        if (!state.alive[state.K - 1][state.K - 1]) return false;
        for (let r = 1; r <= state.K; r += 1) {
          for (let c = 1; c <= state.K; c += 1) {
            if (r === state.K && c === state.K) continue;
            if (state.alive[r - 1][c - 1]) {
              return false;
            }
          }
        }
        return true;
      }

      function legalTargets() {
        const moves = [];
        for (let r = 1; r <= state.K; r += 1) {
          for (let c = 1; c <= state.K; c += 1) {
            if (state.alive[r - 1][c - 1]) moves.push([r, c]);
          }
        }
        return moves;
      }

      function cellsToRemove(row, col) {
        const cells = [];
        for (let r = 1; r <= row; r += 1) {
          for (let c = 1; c <= col; c += 1) {
            if (state.alive[r - 1][c - 1]) {
              cells.push([r, c]);
            }
          }
        }
        return cells;
      }

      function currentPlayer() {
        return state.moveLog.length % 2 === 0 ? 1 : 2;
      }

      function lastMove() {
        return state.moveLog.length
          ? state.moveLog[state.moveLog.length - 1]
          : null;
      }

      function isDiagonalSymmetric() {
        for (let r = 1; r <= state.K; r += 1) {
          for (let c = 1; c <= state.K; c += 1) {
            if (state.alive[r - 1][c - 1] !== state.alive[c - 1][r - 1]) {
              return false;
            }
          }
        }
        return true;
      }

      function mirrorSuggestion() {
        if (!state.helperEnabled) return null;
        if (state.gameOver) return null;
        if (currentPlayer() !== 1) return null;
        if (!isDiagonalSymmetric()) return null;
        if (!state.moveLog.length) {
          return isAlive(1, 1) ? [1, 1] : null;
        }
        const last = lastMove();
        if (!last || last.player !== 2) return null;
        if (last.i !== last.j && isAlive(last.j, last.i)) {
          return [last.j, last.i];
        }
        if (last.i === last.j) {
          for (let r = 1; r <= state.K; r += 1) {
            if (r === last.i) continue;
            if (isAlive(r, r)) {
              return [r, r];
            }
          }
        }
        return null;
      }

      function solverSuggestion() {
        if (!state.solverEnabled || state.K > 6) return null;
        if (state.gameOver) return null;
        const snapshot = snapshotMatrix();
        if (!isWinningMatrix(snapshot)) return null;
        return findWinningMove(snapshot);
      }

      function snapshotMatrix() {
        return state.alive.map((row) => row.slice());
      }

      function encodeMatrix(matrix) {
        return `${matrix.length}|${matrix
          .map((row) => row.map((cell) => (cell ? "1" : "0")).join(""))
          .join("/")}`;
      }

      function isWinningMatrix(matrix) {
        const key = encodeMatrix(matrix);
        if (solverCache.has(key)) return solverCache.get(key);
        if (isTerminalMatrix(matrix)) {
          solverCache.set(key, false);
          return false;
        }
        const moves = generateMoves(matrix);
        for (const [i, j] of moves) {
          if (i === matrix.length && j === matrix.length) continue;
          const next = applyMoveToMatrix(matrix, i, j);
          if (!isWinningMatrix(next)) {
            solverCache.set(key, true);
            return true;
          }
        }
        solverCache.set(key, false);
        return false;
      }

      function findWinningMove(matrix) {
        const moves = generateMoves(matrix);
        for (const [i, j] of moves) {
          if (i === matrix.length && j === matrix.length) continue;
          const next = applyMoveToMatrix(matrix, i, j);
          if (!isWinningMatrix(next)) {
            return [i, j];
          }
        }
        return null;
      }

      function generateMoves(matrix) {
        const moves = [];
        const size = matrix.length;
        for (let r = 1; r <= size; r += 1) {
          for (let c = 1; c <= size; c += 1) {
            if (matrix[r - 1][c - 1]) {
              moves.push([r, c]);
            }
          }
        }
        return moves;
      }

      function applyMoveToMatrix(matrix, row, col) {
        const size = matrix.length;
        const next = matrix.map((r) => r.slice());
        for (let r = 1; r <= row; r += 1) {
          for (let c = 1; c <= col; c += 1) {
            next[r - 1][c - 1] = false;
          }
        }
        return next;
      }

      function isTerminalMatrix(matrix) {
        const size = matrix.length;
        if (!matrix[size - 1][size - 1]) return false;
        for (let r = 1; r <= size; r += 1) {
          for (let c = 1; c <= size; c += 1) {
            if (r === size && c === size) continue;
            if (matrix[r - 1][c - 1]) return false;
          }
        }
        return true;
      }

      function subscript(value) {
        const map = {
          0: "₀",
          1: "₁",
          2: "₂",
          3: "₃",
          4: "₄",
          5: "₅",
          6: "₆",
          7: "₇",
          8: "₈",
          9: "₉",
          i: "ᵢ",
          j: "ⱼ",
          k: "ₖ",
          K: "ₖ",
        };
        return String(value)
          .split("")
          .map((char) => map[char] ?? char)
          .join("");
      }

      applySizeBtn.addEventListener("click", () => {
        const value = Number(sizeInput.value);
        if (Number.isNaN(value)) return;
        const clamped = Math.min(12, Math.max(2, Math.round(value)));
        sizeInput.value = String(clamped);
        solverCache.clear();
        init(clamped);
      });

      modeToggle.addEventListener("click", () => {
        state.vsBot = !state.vsBot;
        if (!state.vsBot) cancelBot();
        render();
        if (state.vsBot && currentPlayer() === 2) {
          queueBotMove();
        }
      });

      helperToggle.addEventListener("click", () => {
        state.helperEnabled = !state.helperEnabled;
        render();
      });

      solverToggle.addEventListener("click", () => {
        if (state.K > 6 || solverToggle.hasAttribute("disabled")) return;
        state.solverEnabled = !state.solverEnabled;
        render();
        if (state.vsBot && currentPlayer() === 2) {
          queueBotMove();
        }
      });

      undoBtn.addEventListener("click", () => {
        undo();
      });

      newGameBtn.addEventListener("click", () => {
        newGame();
      });

      randomBtn.addEventListener("click", () => {
        randomizeFirstMove();
      });

      playAgainBtn.addEventListener("click", () => {
        newGame();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) cancelBot();
      });

      window.addEventListener("beforeunload", () => {
        cancelBot();
      });

      init(state.K);
    </script>
  </body>
</html>
